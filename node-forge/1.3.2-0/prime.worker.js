/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/forge.js":
/*!**********************!*\
  !*** ./lib/forge.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Node.js module for Forge.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright 2011-2016 Digital Bazaar, Inc.\r\n */\r\nmodule.exports = {\r\n  // default options\r\n  options: {\r\n    usePureJavaScript: false\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack:///./lib/forge.js?");

/***/ }),

/***/ "./lib/jsbn.js":
/*!*********************!*\
  !*** ./lib/jsbn.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright (c) 2005  Tom Wu\r\n// All Rights Reserved.\r\n// See \"LICENSE\" for details.\r\n\r\n// Basic JavaScript BN library - subset useful for RSA encryption.\r\n\r\n/*\r\nLicensing (LICENSE)\r\n-------------------\r\n\r\nThis software is covered under the following copyright:\r\n*/\r\n/*\r\n * Copyright (c) 2003-2005  Tom Wu\r\n * All Rights Reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY\r\n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\r\n *\r\n * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,\r\n * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER\r\n * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF\r\n * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT\r\n * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r\n *\r\n * In addition, the following condition applies:\r\n *\r\n * All redistributions must retain an intact copy of this copyright notice\r\n * and disclaimer.\r\n */\r\n/*\r\nAddress all questions regarding this license to:\r\n\r\n  Tom Wu\r\n  tjw@cs.Stanford.EDU\r\n*/\r\nvar forge = __webpack_require__(/*! ./forge */ \"./lib/forge.js\");\r\n\r\nmodule.exports = forge.jsbn = forge.jsbn || {};\r\n\r\n// Bits per digit\r\nvar dbits;\r\n\r\n// JavaScript engine analysis\r\nvar canary = 0xdeadbeefcafe;\r\nvar j_lm = ((canary&0xffffff)==0xefcafe);\r\n\r\n// (public) Constructor\r\nfunction BigInteger(a,b,c) {\r\n  this.data = [];\r\n  if(a != null)\r\n    if(\"number\" == typeof a) this.fromNumber(a,b,c);\r\n    else if(b == null && \"string\" != typeof a) this.fromString(a,256);\r\n    else this.fromString(a,b);\r\n}\r\nforge.jsbn.BigInteger = BigInteger;\r\n\r\n// return new, unset BigInteger\r\nfunction nbi() { return new BigInteger(null); }\r\n\r\n// am: Compute w_j += (x*this_i), propagate carries,\r\n// c is initial carry, returns final carry.\r\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\r\n// We need to select the fastest one that works in this environment.\r\n\r\n// am1: use a single mult and divide to get the high bits,\r\n// max digit bits should be 26 because\r\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\r\nfunction am1(i,x,w,j,c,n) {\r\n  while(--n >= 0) {\r\n    var v = x*this.data[i++]+w.data[j]+c;\r\n    c = Math.floor(v/0x4000000);\r\n    w.data[j++] = v&0x3ffffff;\r\n  }\r\n  return c;\r\n}\r\n// am2 avoids a big mult-and-extract completely.\r\n// Max digit bits should be <= 30 because we do bitwise ops\r\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\r\nfunction am2(i,x,w,j,c,n) {\r\n  var xl = x&0x7fff, xh = x>>15;\r\n  while(--n >= 0) {\r\n    var l = this.data[i]&0x7fff;\r\n    var h = this.data[i++]>>15;\r\n    var m = xh*l+h*xl;\r\n    l = xl*l+((m&0x7fff)<<15)+w.data[j]+(c&0x3fffffff);\r\n    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\r\n    w.data[j++] = l&0x3fffffff;\r\n  }\r\n  return c;\r\n}\r\n// Alternately, set max digit bits to 28 since some\r\n// browsers slow down when dealing with 32-bit numbers.\r\nfunction am3(i,x,w,j,c,n) {\r\n  var xl = x&0x3fff, xh = x>>14;\r\n  while(--n >= 0) {\r\n    var l = this.data[i]&0x3fff;\r\n    var h = this.data[i++]>>14;\r\n    var m = xh*l+h*xl;\r\n    l = xl*l+((m&0x3fff)<<14)+w.data[j]+c;\r\n    c = (l>>28)+(m>>14)+xh*h;\r\n    w.data[j++] = l&0xfffffff;\r\n  }\r\n  return c;\r\n}\r\n\r\n// node.js (no browser)\r\nif(typeof(navigator) === 'undefined')\r\n{\r\n   BigInteger.prototype.am = am3;\r\n   dbits = 28;\r\n} else if(j_lm && (navigator.appName == \"Microsoft Internet Explorer\")) {\r\n  BigInteger.prototype.am = am2;\r\n  dbits = 30;\r\n} else if(j_lm && (navigator.appName != \"Netscape\")) {\r\n  BigInteger.prototype.am = am1;\r\n  dbits = 26;\r\n} else { // Mozilla/Netscape seems to prefer am3\r\n  BigInteger.prototype.am = am3;\r\n  dbits = 28;\r\n}\r\n\r\nBigInteger.prototype.DB = dbits;\r\nBigInteger.prototype.DM = ((1<<dbits)-1);\r\nBigInteger.prototype.DV = (1<<dbits);\r\n\r\nvar BI_FP = 52;\r\nBigInteger.prototype.FV = Math.pow(2,BI_FP);\r\nBigInteger.prototype.F1 = BI_FP-dbits;\r\nBigInteger.prototype.F2 = 2*dbits-BI_FP;\r\n\r\n// Digit conversions\r\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\nvar BI_RC = new Array();\r\nvar rr,vv;\r\nrr = \"0\".charCodeAt(0);\r\nfor(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\r\nrr = \"a\".charCodeAt(0);\r\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\r\nrr = \"A\".charCodeAt(0);\r\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\r\n\r\nfunction int2char(n) { return BI_RM.charAt(n); }\r\nfunction intAt(s,i) {\r\n  var c = BI_RC[s.charCodeAt(i)];\r\n  return (c==null)?-1:c;\r\n}\r\n\r\n// (protected) copy this to r\r\nfunction bnpCopyTo(r) {\r\n  for(var i = this.t-1; i >= 0; --i) r.data[i] = this.data[i];\r\n  r.t = this.t;\r\n  r.s = this.s;\r\n}\r\n\r\n// (protected) set from integer value x, -DV <= x < DV\r\nfunction bnpFromInt(x) {\r\n  this.t = 1;\r\n  this.s = (x<0)?-1:0;\r\n  if(x > 0) this.data[0] = x;\r\n  else if(x < -1) this.data[0] = x+this.DV;\r\n  else this.t = 0;\r\n}\r\n\r\n// return bigint initialized to value\r\nfunction nbv(i) { var r = nbi(); r.fromInt(i); return r; }\r\n\r\n// (protected) set from string and radix\r\nfunction bnpFromString(s,b) {\r\n  var k;\r\n  if(b == 16) k = 4;\r\n  else if(b == 8) k = 3;\r\n  else if(b == 256) k = 8; // byte array\r\n  else if(b == 2) k = 1;\r\n  else if(b == 32) k = 5;\r\n  else if(b == 4) k = 2;\r\n  else { this.fromRadix(s,b); return; }\r\n  this.t = 0;\r\n  this.s = 0;\r\n  var i = s.length, mi = false, sh = 0;\r\n  while(--i >= 0) {\r\n    var x = (k==8)?s[i]&0xff:intAt(s,i);\r\n    if(x < 0) {\r\n      if(s.charAt(i) == \"-\") mi = true;\r\n      continue;\r\n    }\r\n    mi = false;\r\n    if(sh == 0)\r\n      this.data[this.t++] = x;\r\n    else if(sh+k > this.DB) {\r\n      this.data[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\r\n      this.data[this.t++] = (x>>(this.DB-sh));\r\n    } else\r\n      this.data[this.t-1] |= x<<sh;\r\n    sh += k;\r\n    if(sh >= this.DB) sh -= this.DB;\r\n  }\r\n  if(k == 8 && (s[0]&0x80) != 0) {\r\n    this.s = -1;\r\n    if(sh > 0) this.data[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\r\n  }\r\n  this.clamp();\r\n  if(mi) BigInteger.ZERO.subTo(this,this);\r\n}\r\n\r\n// (protected) clamp off excess high words\r\nfunction bnpClamp() {\r\n  var c = this.s&this.DM;\r\n  while(this.t > 0 && this.data[this.t-1] == c) --this.t;\r\n}\r\n\r\n// (public) return string representation in given radix\r\nfunction bnToString(b) {\r\n  if(this.s < 0) return \"-\"+this.negate().toString(b);\r\n  var k;\r\n  if(b == 16) k = 4;\r\n  else if(b == 8) k = 3;\r\n  else if(b == 2) k = 1;\r\n  else if(b == 32) k = 5;\r\n  else if(b == 4) k = 2;\r\n  else return this.toRadix(b);\r\n  var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\r\n  var p = this.DB-(i*this.DB)%k;\r\n  if(i-- > 0) {\r\n    if(p < this.DB && (d = this.data[i]>>p) > 0) { m = true; r = int2char(d); }\r\n    while(i >= 0) {\r\n      if(p < k) {\r\n        d = (this.data[i]&((1<<p)-1))<<(k-p);\r\n        d |= this.data[--i]>>(p+=this.DB-k);\r\n      } else {\r\n        d = (this.data[i]>>(p-=k))&km;\r\n        if(p <= 0) { p += this.DB; --i; }\r\n      }\r\n      if(d > 0) m = true;\r\n      if(m) r += int2char(d);\r\n    }\r\n  }\r\n  return m?r:\"0\";\r\n}\r\n\r\n// (public) -this\r\nfunction bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\r\n\r\n// (public) |this|\r\nfunction bnAbs() { return (this.s<0)?this.negate():this; }\r\n\r\n// (public) return + if this > a, - if this < a, 0 if equal\r\nfunction bnCompareTo(a) {\r\n  var r = this.s-a.s;\r\n  if(r != 0) return r;\r\n  var i = this.t;\r\n  r = i-a.t;\r\n  if(r != 0) return (this.s<0)?-r:r;\r\n  while(--i >= 0) if((r=this.data[i]-a.data[i]) != 0) return r;\r\n  return 0;\r\n}\r\n\r\n// returns bit length of the integer x\r\nfunction nbits(x) {\r\n  var r = 1, t;\r\n  if((t=x>>>16) != 0) { x = t; r += 16; }\r\n  if((t=x>>8) != 0) { x = t; r += 8; }\r\n  if((t=x>>4) != 0) { x = t; r += 4; }\r\n  if((t=x>>2) != 0) { x = t; r += 2; }\r\n  if((t=x>>1) != 0) { x = t; r += 1; }\r\n  return r;\r\n}\r\n\r\n// (public) return the number of bits in \"this\"\r\nfunction bnBitLength() {\r\n  if(this.t <= 0) return 0;\r\n  return this.DB*(this.t-1)+nbits(this.data[this.t-1]^(this.s&this.DM));\r\n}\r\n\r\n// (protected) r = this << n*DB\r\nfunction bnpDLShiftTo(n,r) {\r\n  var i;\r\n  for(i = this.t-1; i >= 0; --i) r.data[i+n] = this.data[i];\r\n  for(i = n-1; i >= 0; --i) r.data[i] = 0;\r\n  r.t = this.t+n;\r\n  r.s = this.s;\r\n}\r\n\r\n// (protected) r = this >> n*DB\r\nfunction bnpDRShiftTo(n,r) {\r\n  for(var i = n; i < this.t; ++i) r.data[i-n] = this.data[i];\r\n  r.t = Math.max(this.t-n,0);\r\n  r.s = this.s;\r\n}\r\n\r\n// (protected) r = this << n\r\nfunction bnpLShiftTo(n,r) {\r\n  var bs = n%this.DB;\r\n  var cbs = this.DB-bs;\r\n  var bm = (1<<cbs)-1;\r\n  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\r\n  for(i = this.t-1; i >= 0; --i) {\r\n    r.data[i+ds+1] = (this.data[i]>>cbs)|c;\r\n    c = (this.data[i]&bm)<<bs;\r\n  }\r\n  for(i = ds-1; i >= 0; --i) r.data[i] = 0;\r\n  r.data[ds] = c;\r\n  r.t = this.t+ds+1;\r\n  r.s = this.s;\r\n  r.clamp();\r\n}\r\n\r\n// (protected) r = this >> n\r\nfunction bnpRShiftTo(n,r) {\r\n  r.s = this.s;\r\n  var ds = Math.floor(n/this.DB);\r\n  if(ds >= this.t) { r.t = 0; return; }\r\n  var bs = n%this.DB;\r\n  var cbs = this.DB-bs;\r\n  var bm = (1<<bs)-1;\r\n  r.data[0] = this.data[ds]>>bs;\r\n  for(var i = ds+1; i < this.t; ++i) {\r\n    r.data[i-ds-1] |= (this.data[i]&bm)<<cbs;\r\n    r.data[i-ds] = this.data[i]>>bs;\r\n  }\r\n  if(bs > 0) r.data[this.t-ds-1] |= (this.s&bm)<<cbs;\r\n  r.t = this.t-ds;\r\n  r.clamp();\r\n}\r\n\r\n// (protected) r = this - a\r\nfunction bnpSubTo(a,r) {\r\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\r\n  while(i < m) {\r\n    c += this.data[i]-a.data[i];\r\n    r.data[i++] = c&this.DM;\r\n    c >>= this.DB;\r\n  }\r\n  if(a.t < this.t) {\r\n    c -= a.s;\r\n    while(i < this.t) {\r\n      c += this.data[i];\r\n      r.data[i++] = c&this.DM;\r\n      c >>= this.DB;\r\n    }\r\n    c += this.s;\r\n  } else {\r\n    c += this.s;\r\n    while(i < a.t) {\r\n      c -= a.data[i];\r\n      r.data[i++] = c&this.DM;\r\n      c >>= this.DB;\r\n    }\r\n    c -= a.s;\r\n  }\r\n  r.s = (c<0)?-1:0;\r\n  if(c < -1) r.data[i++] = this.DV+c;\r\n  else if(c > 0) r.data[i++] = c;\r\n  r.t = i;\r\n  r.clamp();\r\n}\r\n\r\n// (protected) r = this * a, r != this,a (HAC 14.12)\r\n// \"this\" should be the larger one if appropriate.\r\nfunction bnpMultiplyTo(a,r) {\r\n  var x = this.abs(), y = a.abs();\r\n  var i = x.t;\r\n  r.t = i+y.t;\r\n  while(--i >= 0) r.data[i] = 0;\r\n  for(i = 0; i < y.t; ++i) r.data[i+x.t] = x.am(0,y.data[i],r,i,0,x.t);\r\n  r.s = 0;\r\n  r.clamp();\r\n  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\r\n}\r\n\r\n// (protected) r = this^2, r != this (HAC 14.16)\r\nfunction bnpSquareTo(r) {\r\n  var x = this.abs();\r\n  var i = r.t = 2*x.t;\r\n  while(--i >= 0) r.data[i] = 0;\r\n  for(i = 0; i < x.t-1; ++i) {\r\n    var c = x.am(i,x.data[i],r,2*i,0,1);\r\n    if((r.data[i+x.t]+=x.am(i+1,2*x.data[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\r\n      r.data[i+x.t] -= x.DV;\r\n      r.data[i+x.t+1] = 1;\r\n    }\r\n  }\r\n  if(r.t > 0) r.data[r.t-1] += x.am(i,x.data[i],r,2*i,0,1);\r\n  r.s = 0;\r\n  r.clamp();\r\n}\r\n\r\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\r\n// r != q, this != m.  q or r may be null.\r\nfunction bnpDivRemTo(m,q,r) {\r\n  var pm = m.abs();\r\n  if(pm.t <= 0) return;\r\n  var pt = this.abs();\r\n  if(pt.t < pm.t) {\r\n    if(q != null) q.fromInt(0);\r\n    if(r != null) this.copyTo(r);\r\n    return;\r\n  }\r\n  if(r == null) r = nbi();\r\n  var y = nbi(), ts = this.s, ms = m.s;\r\n  var nsh = this.DB-nbits(pm.data[pm.t-1]);\t// normalize modulus\r\n  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); } else { pm.copyTo(y); pt.copyTo(r); }\r\n  var ys = y.t;\r\n  var y0 = y.data[ys-1];\r\n  if(y0 == 0) return;\r\n  var yt = y0*(1<<this.F1)+((ys>1)?y.data[ys-2]>>this.F2:0);\r\n  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\r\n  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\r\n  y.dlShiftTo(j,t);\r\n  if(r.compareTo(t) >= 0) {\r\n    r.data[r.t++] = 1;\r\n    r.subTo(t,r);\r\n  }\r\n  BigInteger.ONE.dlShiftTo(ys,t);\r\n  t.subTo(y,y);\t// \"negative\" y so we can replace sub with am later\r\n  while(y.t < ys) y.data[y.t++] = 0;\r\n  while(--j >= 0) {\r\n    // Estimate quotient digit\r\n    var qd = (r.data[--i]==y0)?this.DM:Math.floor(r.data[i]*d1+(r.data[i-1]+e)*d2);\r\n    if((r.data[i]+=y.am(0,qd,r,j,0,ys)) < qd) {\t// Try it out\r\n      y.dlShiftTo(j,t);\r\n      r.subTo(t,r);\r\n      while(r.data[i] < --qd) r.subTo(t,r);\r\n    }\r\n  }\r\n  if(q != null) {\r\n    r.drShiftTo(ys,q);\r\n    if(ts != ms) BigInteger.ZERO.subTo(q,q);\r\n  }\r\n  r.t = ys;\r\n  r.clamp();\r\n  if(nsh > 0) r.rShiftTo(nsh,r);\t// Denormalize remainder\r\n  if(ts < 0) BigInteger.ZERO.subTo(r,r);\r\n}\r\n\r\n// (public) this mod a\r\nfunction bnMod(a) {\r\n  var r = nbi();\r\n  this.abs().divRemTo(a,null,r);\r\n  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\r\n  return r;\r\n}\r\n\r\n// Modular reduction using \"classic\" algorithm\r\nfunction Classic(m) { this.m = m; }\r\nfunction cConvert(x) {\r\n  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\r\n  else return x;\r\n}\r\nfunction cRevert(x) { return x; }\r\nfunction cReduce(x) { x.divRemTo(this.m,null,x); }\r\nfunction cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\r\nfunction cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\r\n\r\nClassic.prototype.convert = cConvert;\r\nClassic.prototype.revert = cRevert;\r\nClassic.prototype.reduce = cReduce;\r\nClassic.prototype.mulTo = cMulTo;\r\nClassic.prototype.sqrTo = cSqrTo;\r\n\r\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\r\n// justification:\r\n//         xy == 1 (mod m)\r\n//         xy =  1+km\r\n//   xy(2-xy) = (1+km)(1-km)\r\n// x[y(2-xy)] = 1-k^2m^2\r\n// x[y(2-xy)] == 1 (mod m^2)\r\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\r\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\r\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\r\nfunction bnpInvDigit() {\r\n  if(this.t < 1) return 0;\r\n  var x = this.data[0];\r\n  if((x&1) == 0) return 0;\r\n  var y = x&3;\t\t// y == 1/x mod 2^2\r\n  y = (y*(2-(x&0xf)*y))&0xf;\t// y == 1/x mod 2^4\r\n  y = (y*(2-(x&0xff)*y))&0xff;\t// y == 1/x mod 2^8\r\n  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;\t// y == 1/x mod 2^16\r\n  // last step - calculate inverse mod DV directly;\r\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\r\n  y = (y*(2-x*y%this.DV))%this.DV;\t\t// y == 1/x mod 2^dbits\r\n  // we really want the negative inverse, and -DV < y < DV\r\n  return (y>0)?this.DV-y:-y;\r\n}\r\n\r\n// Montgomery reduction\r\nfunction Montgomery(m) {\r\n  this.m = m;\r\n  this.mp = m.invDigit();\r\n  this.mpl = this.mp&0x7fff;\r\n  this.mph = this.mp>>15;\r\n  this.um = (1<<(m.DB-15))-1;\r\n  this.mt2 = 2*m.t;\r\n}\r\n\r\n// xR mod m\r\nfunction montConvert(x) {\r\n  var r = nbi();\r\n  x.abs().dlShiftTo(this.m.t,r);\r\n  r.divRemTo(this.m,null,r);\r\n  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\r\n  return r;\r\n}\r\n\r\n// x/R mod m\r\nfunction montRevert(x) {\r\n  var r = nbi();\r\n  x.copyTo(r);\r\n  this.reduce(r);\r\n  return r;\r\n}\r\n\r\n// x = x/R mod m (HAC 14.32)\r\nfunction montReduce(x) {\r\n  while(x.t <= this.mt2)\t// pad x so am has enough room later\r\n    x.data[x.t++] = 0;\r\n  for(var i = 0; i < this.m.t; ++i) {\r\n    // faster way of calculating u0 = x.data[i]*mp mod DV\r\n    var j = x.data[i]&0x7fff;\r\n    var u0 = (j*this.mpl+(((j*this.mph+(x.data[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\r\n    // use am to combine the multiply-shift-add into one call\r\n    j = i+this.m.t;\r\n    x.data[j] += this.m.am(0,u0,x,i,0,this.m.t);\r\n    // propagate carry\r\n    while(x.data[j] >= x.DV) { x.data[j] -= x.DV; x.data[++j]++; }\r\n  }\r\n  x.clamp();\r\n  x.drShiftTo(this.m.t,x);\r\n  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\r\n}\r\n\r\n// r = \"x^2/R mod m\"; x != r\r\nfunction montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\r\n\r\n// r = \"xy/R mod m\"; x,y != r\r\nfunction montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\r\n\r\nMontgomery.prototype.convert = montConvert;\r\nMontgomery.prototype.revert = montRevert;\r\nMontgomery.prototype.reduce = montReduce;\r\nMontgomery.prototype.mulTo = montMulTo;\r\nMontgomery.prototype.sqrTo = montSqrTo;\r\n\r\n// (protected) true iff this is even\r\nfunction bnpIsEven() { return ((this.t>0)?(this.data[0]&1):this.s) == 0; }\r\n\r\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\r\nfunction bnpExp(e,z) {\r\n  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\r\n  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\r\n  g.copyTo(r);\r\n  while(--i >= 0) {\r\n    z.sqrTo(r,r2);\r\n    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\r\n    else { var t = r; r = r2; r2 = t; }\r\n  }\r\n  return z.revert(r);\r\n}\r\n\r\n// (public) this^e % m, 0 <= e < 2^32\r\nfunction bnModPowInt(e,m) {\r\n  var z;\r\n  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\r\n  return this.exp(e,z);\r\n}\r\n\r\n// protected\r\nBigInteger.prototype.copyTo = bnpCopyTo;\r\nBigInteger.prototype.fromInt = bnpFromInt;\r\nBigInteger.prototype.fromString = bnpFromString;\r\nBigInteger.prototype.clamp = bnpClamp;\r\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\r\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\r\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\r\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\r\nBigInteger.prototype.subTo = bnpSubTo;\r\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\r\nBigInteger.prototype.squareTo = bnpSquareTo;\r\nBigInteger.prototype.divRemTo = bnpDivRemTo;\r\nBigInteger.prototype.invDigit = bnpInvDigit;\r\nBigInteger.prototype.isEven = bnpIsEven;\r\nBigInteger.prototype.exp = bnpExp;\r\n\r\n// public\r\nBigInteger.prototype.toString = bnToString;\r\nBigInteger.prototype.negate = bnNegate;\r\nBigInteger.prototype.abs = bnAbs;\r\nBigInteger.prototype.compareTo = bnCompareTo;\r\nBigInteger.prototype.bitLength = bnBitLength;\r\nBigInteger.prototype.mod = bnMod;\r\nBigInteger.prototype.modPowInt = bnModPowInt;\r\n\r\n// \"constants\"\r\nBigInteger.ZERO = nbv(0);\r\nBigInteger.ONE = nbv(1);\r\n\r\n// jsbn2 lib\r\n\r\n//Copyright (c) 2005-2009  Tom Wu\r\n//All Rights Reserved.\r\n//See \"LICENSE\" for details (See jsbn.js for LICENSE).\r\n\r\n//Extended JavaScript BN functions, required for RSA private ops.\r\n\r\n//Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\r\n\r\n//(public)\r\nfunction bnClone() { var r = nbi(); this.copyTo(r); return r; }\r\n\r\n//(public) return value as integer\r\nfunction bnIntValue() {\r\nif(this.s < 0) {\r\n if(this.t == 1) return this.data[0]-this.DV;\r\n else if(this.t == 0) return -1;\r\n} else if(this.t == 1) return this.data[0];\r\nelse if(this.t == 0) return 0;\r\n// assumes 16 < DB < 32\r\nreturn ((this.data[1]&((1<<(32-this.DB))-1))<<this.DB)|this.data[0];\r\n}\r\n\r\n//(public) return value as byte\r\nfunction bnByteValue() { return (this.t==0)?this.s:(this.data[0]<<24)>>24; }\r\n\r\n//(public) return value as short (assumes DB>=16)\r\nfunction bnShortValue() { return (this.t==0)?this.s:(this.data[0]<<16)>>16; }\r\n\r\n//(protected) return x s.t. r^x < DV\r\nfunction bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\r\n\r\n//(public) 0 if this == 0, 1 if this > 0\r\nfunction bnSigNum() {\r\nif(this.s < 0) return -1;\r\nelse if(this.t <= 0 || (this.t == 1 && this.data[0] <= 0)) return 0;\r\nelse return 1;\r\n}\r\n\r\n//(protected) convert to radix string\r\nfunction bnpToRadix(b) {\r\nif(b == null) b = 10;\r\nif(this.signum() == 0 || b < 2 || b > 36) return \"0\";\r\nvar cs = this.chunkSize(b);\r\nvar a = Math.pow(b,cs);\r\nvar d = nbv(a), y = nbi(), z = nbi(), r = \"\";\r\nthis.divRemTo(d,y,z);\r\nwhile(y.signum() > 0) {\r\n r = (a+z.intValue()).toString(b).substr(1) + r;\r\n y.divRemTo(d,y,z);\r\n}\r\nreturn z.intValue().toString(b) + r;\r\n}\r\n\r\n//(protected) convert from radix string\r\nfunction bnpFromRadix(s,b) {\r\nthis.fromInt(0);\r\nif(b == null) b = 10;\r\nvar cs = this.chunkSize(b);\r\nvar d = Math.pow(b,cs), mi = false, j = 0, w = 0;\r\nfor(var i = 0; i < s.length; ++i) {\r\n var x = intAt(s,i);\r\n if(x < 0) {\r\n   if(s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\r\n   continue;\r\n }\r\n w = b*w+x;\r\n if(++j >= cs) {\r\n   this.dMultiply(d);\r\n   this.dAddOffset(w,0);\r\n   j = 0;\r\n   w = 0;\r\n }\r\n}\r\nif(j > 0) {\r\n this.dMultiply(Math.pow(b,j));\r\n this.dAddOffset(w,0);\r\n}\r\nif(mi) BigInteger.ZERO.subTo(this,this);\r\n}\r\n\r\n//(protected) alternate constructor\r\nfunction bnpFromNumber(a,b,c) {\r\nif(\"number\" == typeof b) {\r\n // new BigInteger(int,int,RNG)\r\n if(a < 2) this.fromInt(1);\r\n else {\r\n   this.fromNumber(a,c);\r\n   if(!this.testBit(a-1))  // force MSB set\r\n     this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\r\n   if(this.isEven()) this.dAddOffset(1,0); // force odd\r\n   while(!this.isProbablePrime(b)) {\r\n     this.dAddOffset(2,0);\r\n     if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\r\n   }\r\n }\r\n} else {\r\n // new BigInteger(int,RNG)\r\n var x = new Array(), t = a&7;\r\n x.length = (a>>3)+1;\r\n b.nextBytes(x);\r\n if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\r\n this.fromString(x,256);\r\n}\r\n}\r\n\r\n//(public) convert to bigendian byte array\r\nfunction bnToByteArray() {\r\nvar i = this.t, r = new Array();\r\nr[0] = this.s;\r\nvar p = this.DB-(i*this.DB)%8, d, k = 0;\r\nif(i-- > 0) {\r\n if(p < this.DB && (d = this.data[i]>>p) != (this.s&this.DM)>>p)\r\n   r[k++] = d|(this.s<<(this.DB-p));\r\n while(i >= 0) {\r\n   if(p < 8) {\r\n     d = (this.data[i]&((1<<p)-1))<<(8-p);\r\n     d |= this.data[--i]>>(p+=this.DB-8);\r\n   } else {\r\n     d = (this.data[i]>>(p-=8))&0xff;\r\n     if(p <= 0) { p += this.DB; --i; }\r\n   }\r\n   if((d&0x80) != 0) d |= -256;\r\n   if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\r\n   if(k > 0 || d != this.s) r[k++] = d;\r\n }\r\n}\r\nreturn r;\r\n}\r\n\r\nfunction bnEquals(a) { return(this.compareTo(a)==0); }\r\nfunction bnMin(a) { return(this.compareTo(a)<0)?this:a; }\r\nfunction bnMax(a) { return(this.compareTo(a)>0)?this:a; }\r\n\r\n//(protected) r = this op a (bitwise)\r\nfunction bnpBitwiseTo(a,op,r) {\r\nvar i, f, m = Math.min(a.t,this.t);\r\nfor(i = 0; i < m; ++i) r.data[i] = op(this.data[i],a.data[i]);\r\nif(a.t < this.t) {\r\n f = a.s&this.DM;\r\n for(i = m; i < this.t; ++i) r.data[i] = op(this.data[i],f);\r\n r.t = this.t;\r\n} else {\r\n f = this.s&this.DM;\r\n for(i = m; i < a.t; ++i) r.data[i] = op(f,a.data[i]);\r\n r.t = a.t;\r\n}\r\nr.s = op(this.s,a.s);\r\nr.clamp();\r\n}\r\n\r\n//(public) this & a\r\nfunction op_and(x,y) { return x&y; }\r\nfunction bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\r\n\r\n//(public) this | a\r\nfunction op_or(x,y) { return x|y; }\r\nfunction bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\r\n\r\n//(public) this ^ a\r\nfunction op_xor(x,y) { return x^y; }\r\nfunction bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\r\n\r\n//(public) this & ~a\r\nfunction op_andnot(x,y) { return x&~y; }\r\nfunction bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\r\n\r\n//(public) ~this\r\nfunction bnNot() {\r\nvar r = nbi();\r\nfor(var i = 0; i < this.t; ++i) r.data[i] = this.DM&~this.data[i];\r\nr.t = this.t;\r\nr.s = ~this.s;\r\nreturn r;\r\n}\r\n\r\n//(public) this << n\r\nfunction bnShiftLeft(n) {\r\nvar r = nbi();\r\nif(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\r\nreturn r;\r\n}\r\n\r\n//(public) this >> n\r\nfunction bnShiftRight(n) {\r\nvar r = nbi();\r\nif(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\r\nreturn r;\r\n}\r\n\r\n//return index of lowest 1-bit in x, x < 2^31\r\nfunction lbit(x) {\r\nif(x == 0) return -1;\r\nvar r = 0;\r\nif((x&0xffff) == 0) { x >>= 16; r += 16; }\r\nif((x&0xff) == 0) { x >>= 8; r += 8; }\r\nif((x&0xf) == 0) { x >>= 4; r += 4; }\r\nif((x&3) == 0) { x >>= 2; r += 2; }\r\nif((x&1) == 0) ++r;\r\nreturn r;\r\n}\r\n\r\n//(public) returns index of lowest 1-bit (or -1 if none)\r\nfunction bnGetLowestSetBit() {\r\nfor(var i = 0; i < this.t; ++i)\r\n if(this.data[i] != 0) return i*this.DB+lbit(this.data[i]);\r\nif(this.s < 0) return this.t*this.DB;\r\nreturn -1;\r\n}\r\n\r\n//return number of 1 bits in x\r\nfunction cbit(x) {\r\nvar r = 0;\r\nwhile(x != 0) { x &= x-1; ++r; }\r\nreturn r;\r\n}\r\n\r\n//(public) return number of set bits\r\nfunction bnBitCount() {\r\nvar r = 0, x = this.s&this.DM;\r\nfor(var i = 0; i < this.t; ++i) r += cbit(this.data[i]^x);\r\nreturn r;\r\n}\r\n\r\n//(public) true iff nth bit is set\r\nfunction bnTestBit(n) {\r\nvar j = Math.floor(n/this.DB);\r\nif(j >= this.t) return(this.s!=0);\r\nreturn((this.data[j]&(1<<(n%this.DB)))!=0);\r\n}\r\n\r\n//(protected) this op (1<<n)\r\nfunction bnpChangeBit(n,op) {\r\nvar r = BigInteger.ONE.shiftLeft(n);\r\nthis.bitwiseTo(r,op,r);\r\nreturn r;\r\n}\r\n\r\n//(public) this | (1<<n)\r\nfunction bnSetBit(n) { return this.changeBit(n,op_or); }\r\n\r\n//(public) this & ~(1<<n)\r\nfunction bnClearBit(n) { return this.changeBit(n,op_andnot); }\r\n\r\n//(public) this ^ (1<<n)\r\nfunction bnFlipBit(n) { return this.changeBit(n,op_xor); }\r\n\r\n//(protected) r = this + a\r\nfunction bnpAddTo(a,r) {\r\nvar i = 0, c = 0, m = Math.min(a.t,this.t);\r\nwhile(i < m) {\r\n c += this.data[i]+a.data[i];\r\n r.data[i++] = c&this.DM;\r\n c >>= this.DB;\r\n}\r\nif(a.t < this.t) {\r\n c += a.s;\r\n while(i < this.t) {\r\n   c += this.data[i];\r\n   r.data[i++] = c&this.DM;\r\n   c >>= this.DB;\r\n }\r\n c += this.s;\r\n} else {\r\n c += this.s;\r\n while(i < a.t) {\r\n   c += a.data[i];\r\n   r.data[i++] = c&this.DM;\r\n   c >>= this.DB;\r\n }\r\n c += a.s;\r\n}\r\nr.s = (c<0)?-1:0;\r\nif(c > 0) r.data[i++] = c;\r\nelse if(c < -1) r.data[i++] = this.DV+c;\r\nr.t = i;\r\nr.clamp();\r\n}\r\n\r\n//(public) this + a\r\nfunction bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\r\n\r\n//(public) this - a\r\nfunction bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\r\n\r\n//(public) this * a\r\nfunction bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\r\n\r\n//(public) this / a\r\nfunction bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\r\n\r\n//(public) this % a\r\nfunction bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\r\n\r\n//(public) [this/a,this%a]\r\nfunction bnDivideAndRemainder(a) {\r\nvar q = nbi(), r = nbi();\r\nthis.divRemTo(a,q,r);\r\nreturn new Array(q,r);\r\n}\r\n\r\n//(protected) this *= n, this >= 0, 1 < n < DV\r\nfunction bnpDMultiply(n) {\r\nthis.data[this.t] = this.am(0,n-1,this,0,0,this.t);\r\n++this.t;\r\nthis.clamp();\r\n}\r\n\r\n//(protected) this += n << w words, this >= 0\r\nfunction bnpDAddOffset(n,w) {\r\nif(n == 0) return;\r\nwhile(this.t <= w) this.data[this.t++] = 0;\r\nthis.data[w] += n;\r\nwhile(this.data[w] >= this.DV) {\r\n this.data[w] -= this.DV;\r\n if(++w >= this.t) this.data[this.t++] = 0;\r\n ++this.data[w];\r\n}\r\n}\r\n\r\n//A \"null\" reducer\r\nfunction NullExp() {}\r\nfunction nNop(x) { return x; }\r\nfunction nMulTo(x,y,r) { x.multiplyTo(y,r); }\r\nfunction nSqrTo(x,r) { x.squareTo(r); }\r\n\r\nNullExp.prototype.convert = nNop;\r\nNullExp.prototype.revert = nNop;\r\nNullExp.prototype.mulTo = nMulTo;\r\nNullExp.prototype.sqrTo = nSqrTo;\r\n\r\n//(public) this^e\r\nfunction bnPow(e) { return this.exp(e,new NullExp()); }\r\n\r\n//(protected) r = lower n words of \"this * a\", a.t <= n\r\n//\"this\" should be the larger one if appropriate.\r\nfunction bnpMultiplyLowerTo(a,n,r) {\r\nvar i = Math.min(this.t+a.t,n);\r\nr.s = 0; // assumes a,this >= 0\r\nr.t = i;\r\nwhile(i > 0) r.data[--i] = 0;\r\nvar j;\r\nfor(j = r.t-this.t; i < j; ++i) r.data[i+this.t] = this.am(0,a.data[i],r,i,0,this.t);\r\nfor(j = Math.min(a.t,n); i < j; ++i) this.am(0,a.data[i],r,i,0,n-i);\r\nr.clamp();\r\n}\r\n\r\n//(protected) r = \"this * a\" without lower n words, n > 0\r\n//\"this\" should be the larger one if appropriate.\r\nfunction bnpMultiplyUpperTo(a,n,r) {\r\n--n;\r\nvar i = r.t = this.t+a.t-n;\r\nr.s = 0; // assumes a,this >= 0\r\nwhile(--i >= 0) r.data[i] = 0;\r\nfor(i = Math.max(n-this.t,0); i < a.t; ++i)\r\n r.data[this.t+i-n] = this.am(n-i,a.data[i],r,0,0,this.t+i-n);\r\nr.clamp();\r\nr.drShiftTo(1,r);\r\n}\r\n\r\n//Barrett modular reduction\r\nfunction Barrett(m) {\r\n// setup Barrett\r\nthis.r2 = nbi();\r\nthis.q3 = nbi();\r\nBigInteger.ONE.dlShiftTo(2*m.t,this.r2);\r\nthis.mu = this.r2.divide(m);\r\nthis.m = m;\r\n}\r\n\r\nfunction barrettConvert(x) {\r\nif(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\r\nelse if(x.compareTo(this.m) < 0) return x;\r\nelse { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\r\n}\r\n\r\nfunction barrettRevert(x) { return x; }\r\n\r\n//x = x mod m (HAC 14.42)\r\nfunction barrettReduce(x) {\r\nx.drShiftTo(this.m.t-1,this.r2);\r\nif(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\r\nthis.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\r\nthis.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\r\nwhile(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\r\nx.subTo(this.r2,x);\r\nwhile(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\r\n}\r\n\r\n//r = x^2 mod m; x != r\r\nfunction barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\r\n\r\n//r = x*y mod m; x,y != r\r\nfunction barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\r\n\r\nBarrett.prototype.convert = barrettConvert;\r\nBarrett.prototype.revert = barrettRevert;\r\nBarrett.prototype.reduce = barrettReduce;\r\nBarrett.prototype.mulTo = barrettMulTo;\r\nBarrett.prototype.sqrTo = barrettSqrTo;\r\n\r\n//(public) this^e % m (HAC 14.85)\r\nfunction bnModPow(e,m) {\r\nvar i = e.bitLength(), k, r = nbv(1), z;\r\nif(i <= 0) return r;\r\nelse if(i < 18) k = 1;\r\nelse if(i < 48) k = 3;\r\nelse if(i < 144) k = 4;\r\nelse if(i < 768) k = 5;\r\nelse k = 6;\r\nif(i < 8)\r\n z = new Classic(m);\r\nelse if(m.isEven())\r\n z = new Barrett(m);\r\nelse\r\n z = new Montgomery(m);\r\n\r\n// precomputation\r\nvar g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\r\ng[1] = z.convert(this);\r\nif(k > 1) {\r\n var g2 = nbi();\r\n z.sqrTo(g[1],g2);\r\n while(n <= km) {\r\n   g[n] = nbi();\r\n   z.mulTo(g2,g[n-2],g[n]);\r\n   n += 2;\r\n }\r\n}\r\n\r\nvar j = e.t-1, w, is1 = true, r2 = nbi(), t;\r\ni = nbits(e.data[j])-1;\r\nwhile(j >= 0) {\r\n if(i >= k1) w = (e.data[j]>>(i-k1))&km;\r\n else {\r\n   w = (e.data[j]&((1<<(i+1))-1))<<(k1-i);\r\n   if(j > 0) w |= e.data[j-1]>>(this.DB+i-k1);\r\n }\r\n\r\n n = k;\r\n while((w&1) == 0) { w >>= 1; --n; }\r\n if((i -= n) < 0) { i += this.DB; --j; }\r\n if(is1) {  // ret == 1, don't bother squaring or multiplying it\r\n   g[w].copyTo(r);\r\n   is1 = false;\r\n } else {\r\n   while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\r\n   if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\r\n   z.mulTo(r2,g[w],r);\r\n }\r\n\r\n while(j >= 0 && (e.data[j]&(1<<i)) == 0) {\r\n   z.sqrTo(r,r2); t = r; r = r2; r2 = t;\r\n   if(--i < 0) { i = this.DB-1; --j; }\r\n }\r\n}\r\nreturn z.revert(r);\r\n}\r\n\r\n//(public) gcd(this,a) (HAC 14.54)\r\nfunction bnGCD(a) {\r\nvar x = (this.s<0)?this.negate():this.clone();\r\nvar y = (a.s<0)?a.negate():a.clone();\r\nif(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\r\nvar i = x.getLowestSetBit(), g = y.getLowestSetBit();\r\nif(g < 0) return x;\r\nif(i < g) g = i;\r\nif(g > 0) {\r\n x.rShiftTo(g,x);\r\n y.rShiftTo(g,y);\r\n}\r\nwhile(x.signum() > 0) {\r\n if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\r\n if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\r\n if(x.compareTo(y) >= 0) {\r\n   x.subTo(y,x);\r\n   x.rShiftTo(1,x);\r\n } else {\r\n   y.subTo(x,y);\r\n   y.rShiftTo(1,y);\r\n }\r\n}\r\nif(g > 0) y.lShiftTo(g,y);\r\nreturn y;\r\n}\r\n\r\n//(protected) this % n, n < 2^26\r\nfunction bnpModInt(n) {\r\nif(n <= 0) return 0;\r\nvar d = this.DV%n, r = (this.s<0)?n-1:0;\r\nif(this.t > 0)\r\n if(d == 0) r = this.data[0]%n;\r\n else for(var i = this.t-1; i >= 0; --i) r = (d*r+this.data[i])%n;\r\nreturn r;\r\n}\r\n\r\n//(public) 1/this % m (HAC 14.61)\r\nfunction bnModInverse(m) {\r\nvar ac = m.isEven();\r\nif((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\r\nvar u = m.clone(), v = this.clone();\r\nvar a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\r\nwhile(u.signum() != 0) {\r\n while(u.isEven()) {\r\n   u.rShiftTo(1,u);\r\n   if(ac) {\r\n     if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\r\n     a.rShiftTo(1,a);\r\n   } else if(!b.isEven()) b.subTo(m,b);\r\n   b.rShiftTo(1,b);\r\n }\r\n while(v.isEven()) {\r\n   v.rShiftTo(1,v);\r\n   if(ac) {\r\n     if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\r\n     c.rShiftTo(1,c);\r\n   } else if(!d.isEven()) d.subTo(m,d);\r\n   d.rShiftTo(1,d);\r\n }\r\n if(u.compareTo(v) >= 0) {\r\n   u.subTo(v,u);\r\n   if(ac) a.subTo(c,a);\r\n   b.subTo(d,b);\r\n } else {\r\n   v.subTo(u,v);\r\n   if(ac) c.subTo(a,c);\r\n   d.subTo(b,d);\r\n }\r\n}\r\nif(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\r\nif(d.compareTo(m) >= 0) return d.subtract(m);\r\nif(d.signum() < 0) d.addTo(m,d); else return d;\r\nif(d.signum() < 0) return d.add(m); else return d;\r\n}\r\n\r\nvar lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];\r\nvar lplim = (1<<26)/lowprimes[lowprimes.length-1];\r\n\r\n//(public) test primality with certainty >= 1-.5^t\r\nfunction bnIsProbablePrime(t) {\r\nvar i, x = this.abs();\r\nif(x.t == 1 && x.data[0] <= lowprimes[lowprimes.length-1]) {\r\n for(i = 0; i < lowprimes.length; ++i)\r\n   if(x.data[0] == lowprimes[i]) return true;\r\n return false;\r\n}\r\nif(x.isEven()) return false;\r\ni = 1;\r\nwhile(i < lowprimes.length) {\r\n var m = lowprimes[i], j = i+1;\r\n while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\r\n m = x.modInt(m);\r\n while(i < j) if(m%lowprimes[i++] == 0) return false;\r\n}\r\nreturn x.millerRabin(t);\r\n}\r\n\r\n//(protected) true if probably prime (HAC 4.24, Miller-Rabin)\r\nfunction bnpMillerRabin(t) {\r\nvar n1 = this.subtract(BigInteger.ONE);\r\nvar k = n1.getLowestSetBit();\r\nif(k <= 0) return false;\r\nvar r = n1.shiftRight(k);\r\nvar prng = bnGetPrng();\r\nvar a;\r\nfor(var i = 0; i < t; ++i) {\r\n // select witness 'a' at random from between 1 and n1\r\n do {\r\n   a = new BigInteger(this.bitLength(), prng);\r\n }\r\n while(a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);\r\n var y = a.modPow(r,this);\r\n if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\r\n   var j = 1;\r\n   while(j++ < k && y.compareTo(n1) != 0) {\r\n     y = y.modPowInt(2,this);\r\n     if(y.compareTo(BigInteger.ONE) == 0) return false;\r\n   }\r\n   if(y.compareTo(n1) != 0) return false;\r\n }\r\n}\r\nreturn true;\r\n}\r\n\r\n// get pseudo random number generator\r\nfunction bnGetPrng() {\r\n  // create prng with api that matches BigInteger secure random\r\n  return {\r\n    // x is an array to fill with bytes\r\n    nextBytes: function(x) {\r\n      for(var i = 0; i < x.length; ++i) {\r\n        x[i] = Math.floor(Math.random() * 0x0100);\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\n//protected\r\nBigInteger.prototype.chunkSize = bnpChunkSize;\r\nBigInteger.prototype.toRadix = bnpToRadix;\r\nBigInteger.prototype.fromRadix = bnpFromRadix;\r\nBigInteger.prototype.fromNumber = bnpFromNumber;\r\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\r\nBigInteger.prototype.changeBit = bnpChangeBit;\r\nBigInteger.prototype.addTo = bnpAddTo;\r\nBigInteger.prototype.dMultiply = bnpDMultiply;\r\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\r\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\r\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\r\nBigInteger.prototype.modInt = bnpModInt;\r\nBigInteger.prototype.millerRabin = bnpMillerRabin;\r\n\r\n//public\r\nBigInteger.prototype.clone = bnClone;\r\nBigInteger.prototype.intValue = bnIntValue;\r\nBigInteger.prototype.byteValue = bnByteValue;\r\nBigInteger.prototype.shortValue = bnShortValue;\r\nBigInteger.prototype.signum = bnSigNum;\r\nBigInteger.prototype.toByteArray = bnToByteArray;\r\nBigInteger.prototype.equals = bnEquals;\r\nBigInteger.prototype.min = bnMin;\r\nBigInteger.prototype.max = bnMax;\r\nBigInteger.prototype.and = bnAnd;\r\nBigInteger.prototype.or = bnOr;\r\nBigInteger.prototype.xor = bnXor;\r\nBigInteger.prototype.andNot = bnAndNot;\r\nBigInteger.prototype.not = bnNot;\r\nBigInteger.prototype.shiftLeft = bnShiftLeft;\r\nBigInteger.prototype.shiftRight = bnShiftRight;\r\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\r\nBigInteger.prototype.bitCount = bnBitCount;\r\nBigInteger.prototype.testBit = bnTestBit;\r\nBigInteger.prototype.setBit = bnSetBit;\r\nBigInteger.prototype.clearBit = bnClearBit;\r\nBigInteger.prototype.flipBit = bnFlipBit;\r\nBigInteger.prototype.add = bnAdd;\r\nBigInteger.prototype.subtract = bnSubtract;\r\nBigInteger.prototype.multiply = bnMultiply;\r\nBigInteger.prototype.divide = bnDivide;\r\nBigInteger.prototype.remainder = bnRemainder;\r\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\r\nBigInteger.prototype.modPow = bnModPow;\r\nBigInteger.prototype.modInverse = bnModInverse;\r\nBigInteger.prototype.pow = bnPow;\r\nBigInteger.prototype.gcd = bnGCD;\r\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\r\n\r\n//BigInteger interfaces not implemented in jsbn:\r\n\r\n//BigInteger(int signum, byte[] magnitude)\r\n//double doubleValue()\r\n//float floatValue()\r\n//int hashCode()\r\n//long longValue()\r\n//static BigInteger valueOf(long val)\r\n\n\n//# sourceURL=webpack:///./lib/jsbn.js?");

/***/ }),

/***/ "./lib/prime.worker.js":
/*!*****************************!*\
  !*** ./lib/prime.worker.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * RSA Key Generation Worker.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2013 Digital Bazaar, Inc.\r\n */\r\n// worker is built using CommonJS syntax to include all code in one worker file\r\n//importScripts('jsbn.js');\r\nvar forge = __webpack_require__(/*! ./forge */ \"./lib/forge.js\");\r\n__webpack_require__(/*! ./jsbn */ \"./lib/jsbn.js\");\r\n\r\n// prime constants\r\nvar LOW_PRIMES = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\r\nvar LP_LIMIT = (1 << 26) / LOW_PRIMES[LOW_PRIMES.length - 1];\r\n\r\nvar BigInteger = forge.jsbn.BigInteger;\r\nvar BIG_TWO = new BigInteger(null);\r\nBIG_TWO.fromInt(2);\r\n\r\nself.addEventListener('message', function(e) {\r\n  var result = findPrime(e.data);\r\n  self.postMessage(result);\r\n});\r\n\r\n// start receiving ranges to check\r\nself.postMessage({found: false});\r\n\r\n// primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\r\nvar GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\r\n\r\nfunction findPrime(data) {\r\n  // TODO: abstract based on data.algorithm (PRIMEINC vs. others)\r\n\r\n  // create BigInteger from given random bytes\r\n  var num = new BigInteger(data.hex, 16);\r\n\r\n  /* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The\r\n    number we are given is always aligned at 30k + 1. Each time the number is\r\n    determined not to be prime we add to get to the next 'i', eg: if the number\r\n    was at 30k + 1 we add 6. */\r\n  var deltaIdx = 0;\r\n\r\n  // find nearest prime\r\n  var workLoad = data.workLoad;\r\n  for(var i = 0; i < workLoad; ++i) {\r\n    // do primality test\r\n    if(isProbablePrime(num)) {\r\n      return {found: true, prime: num.toString(16)};\r\n    }\r\n    // get next potential prime\r\n    num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\r\n  }\r\n\r\n  return {found: false};\r\n}\r\n\r\nfunction isProbablePrime(n) {\r\n  // divide by low primes, ignore even checks, etc (n alread aligned properly)\r\n  var i = 1;\r\n  while(i < LOW_PRIMES.length) {\r\n    var m = LOW_PRIMES[i];\r\n    var j = i + 1;\r\n    while(j < LOW_PRIMES.length && m < LP_LIMIT) {\r\n      m *= LOW_PRIMES[j++];\r\n    }\r\n    m = n.modInt(m);\r\n    while(i < j) {\r\n      if(m % LOW_PRIMES[i++] === 0) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return runMillerRabin(n);\r\n}\r\n\r\n// HAC 4.24, Miller-Rabin\r\nfunction runMillerRabin(n) {\r\n  // n1 = n - 1\r\n  var n1 = n.subtract(BigInteger.ONE);\r\n\r\n  // get s and d such that n1 = 2^s * d\r\n  var s = n1.getLowestSetBit();\r\n  if(s <= 0) {\r\n    return false;\r\n  }\r\n  var d = n1.shiftRight(s);\r\n\r\n  var k = _getMillerRabinTests(n.bitLength());\r\n  var prng = getPrng();\r\n  var a;\r\n  for(var i = 0; i < k; ++i) {\r\n    // select witness 'a' at random from between 1 and n - 1\r\n    do {\r\n      a = new BigInteger(n.bitLength(), prng);\r\n    } while(a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);\r\n\r\n    /* See if 'a' is a composite witness. */\r\n\r\n    // x = a^d mod n\r\n    var x = a.modPow(d, n);\r\n\r\n    // probably prime\r\n    if(x.compareTo(BigInteger.ONE) === 0 || x.compareTo(n1) === 0) {\r\n      continue;\r\n    }\r\n\r\n    var j = s;\r\n    while(--j) {\r\n      // x = x^2 mod a\r\n      x = x.modPowInt(2, n);\r\n\r\n      // 'n' is composite because no previous x == -1 mod n\r\n      if(x.compareTo(BigInteger.ONE) === 0) {\r\n        return false;\r\n      }\r\n      // x == -1 mod n, so probably prime\r\n      if(x.compareTo(n1) === 0) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // 'x' is first_x^(n1/2) and is not +/- 1, so 'n' is not prime\r\n    if(j === 0) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// get pseudo random number generator\r\nfunction getPrng() {\r\n  // create prng with api that matches BigInteger secure random\r\n  return {\r\n    // x is an array to fill with bytes\r\n    nextBytes: function(x) {\r\n      for(var i = 0; i < x.length; ++i) {\r\n        x[i] = Math.floor(Math.random() * 0xFF);\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Returns the required number of Miller-Rabin tests to generate a\r\n * prime with an error probability of (1/2)^80.\r\n *\r\n * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\r\n *\r\n * @param bits the bit size.\r\n *\r\n * @return the required number of iterations.\r\n */\r\nfunction _getMillerRabinTests(bits) {\r\n  if(bits <= 100) return 27;\r\n  if(bits <= 150) return 18;\r\n  if(bits <= 200) return 15;\r\n  if(bits <= 250) return 12;\r\n  if(bits <= 300) return 9;\r\n  if(bits <= 350) return 8;\r\n  if(bits <= 400) return 7;\r\n  if(bits <= 500) return 6;\r\n  if(bits <= 600) return 5;\r\n  if(bits <= 800) return 4;\r\n  if(bits <= 1250) return 3;\r\n  return 2;\r\n}\r\n\n\n//# sourceURL=webpack:///./lib/prime.worker.js?");

/***/ }),

/***/ 0:
/*!**************************************************!*\
  !*** multi ./lib/prime.worker.js ./lib/forge.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./lib/prime.worker.js */\"./lib/prime.worker.js\");\nmodule.exports = __webpack_require__(/*! ./lib/forge.js */\"./lib/forge.js\");\n\n\n//# sourceURL=webpack:///multi_./lib/prime.worker.js_./lib/forge.js?");

/***/ })

/******/ });